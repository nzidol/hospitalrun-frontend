/**
 * HospitalRunFHIRAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io )
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class PatientController {
    /**
     * The history interaction retrieves the history of either a particular resource or all
     * resources of a given type.
     *
     * @param {string} count (optional) TODO: type description here
     * @param {string} since (optional) TODO: type description here
     * @param {string} active (optional) Whether the patient record is active
     * @param {string} address (optional) An address in any kind of address/part of the patient
     * @param {string} addressCity (optional) A city specified in an address
     * @param {string} addressCountry (optional) A country specified in an address
     * @param {string} addressPostalcode (optional) A postalCode specified in an address
     * @param {string} addressState (optional) A state specified in an address
     * @param {string} addressUse (optional) A use code specified in an address
     * @param {string} animalBreed (optional) The breed for animal patients
     * @param {string} animalSpecies (optional) The species for animal patients
     * @param {string} birthdate (optional) The patient's date of birth
     * @param {string} careprovider (optional) Patient's nominated care provider, could be a care
     * manager, not the organization that manages the record
     * @param {string} deathdate (optional) The date of death has been provided and satisfies this
     * search value
     * @param {string} deceased (optional) This patient has been marked as deceased, or as a death
     * date entered
     * @param {string} email (optional) A value in an email contact
     * @param {string} family (optional) A portion of the family name of the patient
     * @param {string} gender (optional) Gender of the patient
     * @param {string} given (optional) A portion of the given name of the patient
     * @param {object} identifier (optional) A patient identifier
     * @param {string} language (optional) Language code (irrespective of use value)
     * @param {string} link (optional) All patients linked to the given patient
     * @param {string} name (optional) A portion of either family or given name of the patient
     * @param {string} organization (optional) The organization at which this person is a patient
     * @param {string} phone (optional) A value in a phone contact
     * @param {string} phonetic (optional) A portion of either family or given name using some kind
     * of phonetic matching algorithm
     * @param {string} telecom (optional) The value in any kind of telecom details of the patient
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientHistory(
        count,
        since,
        active,
        address,
        addressCity,
        addressCountry,
        addressPostalcode,
        addressState,
        addressUse,
        animalBreed,
        animalSpecies,
        birthdate,
        careprovider,
        deathdate,
        deceased,
        email,
        family,
        gender,
        given,
        identifier,
        language,
        link,
        name,
        organization,
        phone,
        phonetic,
        telecom,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/_history'}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _count: count,
            _since: since,
            active,
            address,
            addressCity,
            addressCountry,
            addressPostalcode,
            addressState,
            addressUse,
            animalBreed,
            animalSpecies,
            birthdate,
            careprovider,
            deathdate,
            deceased,
            email,
            family,
            gender,
            given,
            identifier,
            language,
            link,
            name,
            organization,
            phone,
            phonetic,
            telecom,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'PatientBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * The history interaction retrieves the history of either a particular resource or all
     * resources of a given type.
     *
     * @param {string} id TODO: type description here
     * @param {string} count (optional) TODO: type description here
     * @param {string} since (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientHistoryById(id, count, since, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}/_history'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _count: count,
            _since: since,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'PatientBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * The vread interaction preforms a version specific read of the resource.
     *
     * @param {string} id TODO: type description here
     * @param {string} vid TODO: type description here
     * @param {FormatEnum} format (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientByIdAndVid(id, vid, format, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}/{vid}'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
            vid,
        });

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _format: (format !== null) ? format : null,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'Patient');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * @todo Add general description for this endpoint
     *
     * @param {string} id TODO: type description here
     * @param {string} id1 (optional) Resource id (not a full URL)
     * @param {string} content (optional) Text search against the entire resource
     * @param {string} lastUpdated (optional) Date last updated. Server has discretion on the
     * boundary precision
     * @param {string} tag (optional) Search by a resource tag
     * @param {string} profile (optional) Search for all resources tagged with a profile
     * @param {string} security (optional) Search by a security label
     * @param {string} text (optional) Text search against the narrative
     * @param {string} list (optional) All resources in nominated list (by id, not a full URL)
     * @param {string} query (optional) Custom named query
     * @param {string} sort (optional) Order to sort results in (can repeat for inner sort orders)
     * @param {string} count (optional) Number of results per page
     * @param {string} include (optional) Other resources to include in the search results that
     * search matches point to
     * @param {string} revinclude (optional) Other resources to include in the search results when
     * they refer to search matches
     * @param {string} summary (optional) Just return the summary elements (for resources where
     * this is defined)
     * @param {string} contained (optional) Whether to return resources contained in other
     * resources in the search matches
     * @param {string} containedType (optional) If returning contained resources, whether to return
     * the contained or container resources
     * @param {string} asserter (optional) Person who asserts this condition
     * @param {string} bodySite (optional) Anatomical location, if relevant
     * @param {string} category (optional) The category of the condition
     * @param {string} clinicalstatus (optional) The clinical status of the condition
     * @param {int} code (optional) Code for the condition
     * @param {string} dateRecorded (optional) A date, when the Condition statement was documented
     * @param {string} encounter (optional) Encounter when condition first asserted
     * @param {string} evidence (optional) Manifestation/symptom
     * @param {object} identifier (optional) A unique identifier of the condition record
     * @param {string} onset (optional) Date related onsets (dateTime and Period)
     * @param {string} onsetInfo (optional) Other onsets (boolean, age, range, string)
     * @param {string} patient (optional) Who has the condition?
     * @param {string} severity (optional) The severity of the condition
     * @param {string} stage (optional) Simple summary (disease specific)
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientConditionById(
        id,
        id1,
        content,
        lastUpdated,
        tag,
        profile,
        security,
        text,
        list,
        query,
        sort,
        count,
        include,
        revinclude,
        summary,
        contained,
        containedType,
        asserter,
        bodySite,
        category,
        clinicalstatus,
        code,
        dateRecorded,
        encounter,
        evidence,
        identifier,
        onset,
        onsetInfo,
        patient,
        severity,
        stage,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}/Condition'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _id1: id1,
            _content: content,
            _lastUpdated: lastUpdated,
            _tag: tag,
            _profile: profile,
            _security: security,
            _text: text,
            _list: list,
            _query: query,
            _sort: sort,
            _count: count,
            _include: include,
            _revinclude: revinclude,
            _summary: summary,
            _contained: contained,
            _containedType: containedType,
            asserter,
            bodySite,
            category,
            clinicalstatus,
            code,
            dateRecorded,
            encounter,
            evidence,
            identifier,
            onset,
            onsetInfo,
            patient,
            severity,
            stage,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'ConditionBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * @todo Add general description for this endpoint
     *
     * @param {string} id TODO: type description here
     * @param {string} id1 (optional) Resource id (not a full URL)
     * @param {string} content (optional) Text search against the entire resource
     * @param {string} lastUpdated (optional) Date last updated. Server has discretion on the
     * boundary precision
     * @param {string} tag (optional) Search by a resource tag
     * @param {string} profile (optional) Search for all resources tagged with a profile
     * @param {string} security (optional) Search by a security label
     * @param {string} text (optional) Text search against the narrative
     * @param {string} list (optional) All resources in nominated list (by id, not a full URL)
     * @param {string} query (optional) Custom named query
     * @param {string} sort (optional) Order to sort results in (can repeat for inner sort orders)
     * @param {string} count (optional) Number of results per page
     * @param {string} include (optional) Other resources to include in the search results that
     * search matches point to
     * @param {string} revinclude (optional) Other resources to include in the search results when
     * they refer to search matches
     * @param {string} summary (optional) Just return the summary elements (for resources where
     * this is defined)
     * @param {string} contained (optional) Whether to return resources contained in other
     * resources in the search matches
     * @param {string} containedType (optional) If returning contained resources, whether to return
     * the contained or container resources
     * @param {string} category (optional) The classification of the type of observation
     * @param {string} code (optional) The code of the observation type
     * @param {string} componentCode (optional) The component code of the observation type
     * @param {string} componentDataAbsentReason (optional) The reason why the expected value in
     * the element Observation.component.value[x] is
     * missing.
     * @param {string} componentValueConcept (optional) The value of the component observation, if
     * the value is a CodeableConcept
     * @param {string} componentValueQuantity (optional) The value of the component observation, if
     * the value is a Quantity, or a SampledData (just
     * search on the bounds of the values in sampled data)
     * @param {string} componentValueString (optional) The value of the component observation, if
     * the value is a string, and also searches in
     * CodeableConcept.text
     * @param {string} dataAbsentReason (optional) The reason why the expected value in the element
     * Observation.value[x] is missing.
     * @param {string} date (optional) Obtained date/time. If the obtained element is a period, a
     * date that falls in the period
     * @param {string} device (optional) The Device that generated the observation data.
     * @param {string} encounter (optional) Healthcare event related to the observation
     * @param {object} identifier (optional) The unique id for a particular observation
     * @param {string} patient (optional) The subject that the observation is about (if patient)
     * @param {string} performer (optional) Who performed the observation
     * @param {string} related (optional) Related Observations - search on related-type and related-
     * target together
     * @param {string} relatedTarget (optional) Resource that is related to this one
     * @param {string} relatedType (optional) has-member | derived-from | sequel-to | replaces |
     * qualified-by | interfered-by
     * @param {string} specimen (optional) Specimen used for this observation
     * @param {string} status (optional) The status of the observation
     * @param {string} subject (optional) The subject that the observation is about
     * @param {string} valueConcept (optional) The value of the observation, if the value is a
     * CodeableConcept
     * @param {string} valueDate (optional) The value of the observation, if the value is a date or
     * period of time
     * @param {string} valueQuantity (optional) The value of the observation, if the value is a
     * Quantity, or a SampledData (just search on the bounds of the
     * values in sampled data)
     * @param {string} valueString (optional) The value of the observation, if the value is a
     * string, and also searches in CodeableConcept.text
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientObservationById(
        id,
        id1,
        content,
        lastUpdated,
        tag,
        profile,
        security,
        text,
        list,
        query,
        sort,
        count,
        include,
        revinclude,
        summary,
        contained,
        containedType,
        category,
        code,
        componentCode,
        componentDataAbsentReason,
        componentValueConcept,
        componentValueQuantity,
        componentValueString,
        dataAbsentReason,
        date,
        device,
        encounter,
        identifier,
        patient,
        performer,
        related,
        relatedTarget,
        relatedType,
        specimen,
        status,
        subject,
        valueConcept,
        valueDate,
        valueQuantity,
        valueString,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}/Observation'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _id1: id1,
            _content: content,
            _lastUpdated: lastUpdated,
            _tag: tag,
            _profile: profile,
            _security: security,
            _text: text,
            _list: list,
            _query: query,
            _sort: sort,
            _count: count,
            _include: include,
            _revinclude: revinclude,
            _summary: summary,
            _contained: contained,
            _containedType: containedType,
            category,
            code,
            componentCode,
            componentDataAbsentReason,
            componentValueConcept,
            componentValueQuantity,
            componentValueString,
            dataAbsentReason,
            date,
            device,
            encounter,
            identifier,
            patient,
            performer,
            related,
            relatedTarget,
            relatedType,
            specimen,
            status,
            subject,
            valueConcept,
            valueDate,
            valueQuantity,
            valueString,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'ObservationBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * @todo Add general description for this endpoint
     *
     * @param {string} id TODO: type description here
     * @param {string} id1 (optional) Resource id (not a full URL)
     * @param {string} content (optional) Text search against the entire resource
     * @param {string} lastUpdated (optional) Date last updated. Server has discretion on the
     * boundary precision
     * @param {string} tag (optional) Search by a resource tag
     * @param {string} profile (optional) Search for all resources tagged with a profile
     * @param {string} security (optional) Search by a security label
     * @param {string} text (optional) Text search against the narrative
     * @param {string} list (optional) All resources in nominated list (by id, not a full URL)
     * @param {string} query (optional) Custom named query
     * @param {string} sort (optional) Order to sort results in (can repeat for inner sort orders)
     * @param {string} count (optional) Number of results per page
     * @param {string} include (optional) Other resources to include in the search results that
     * search matches point to
     * @param {string} revinclude (optional) Other resources to include in the search results when
     * they refer to search matches
     * @param {string} summary (optional) Just return the summary elements (for resources where
     * this is defined)
     * @param {string} contained (optional) Whether to return resources contained in other
     * resources in the search matches
     * @param {string} containedType (optional) If returning contained resources, whether to return
     * the contained or container resources
     * @param {string} code (optional) Return administrations of this medication code
     * @param {string} datewritten (optional) Return prescriptions written on this date
     * @param {string} encounter (optional) Return prescriptions with this encounter identifier
     * @param {object} identifier (optional) Return prescriptions with this external identifier
     * @param {string} medication (optional) Return administrations of this medication reference
     * @param {string} patient (optional) The identity of a patient to list orders for
     * @param {string} prescriber (optional) Who ordered the medication(s)
     * @param {string} status (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientMedicationOrderById(
        id,
        id1,
        content,
        lastUpdated,
        tag,
        profile,
        security,
        text,
        list,
        query,
        sort,
        count,
        include,
        revinclude,
        summary,
        contained,
        containedType,
        code,
        datewritten,
        encounter,
        identifier,
        medication,
        patient,
        prescriber,
        status,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}/MedicationOrder'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _id1: id1,
            _content: content,
            _lastUpdated: lastUpdated,
            _tag: tag,
            _profile: profile,
            _security: security,
            _text: text,
            _list: list,
            _query: query,
            _sort: sort,
            _count: count,
            _include: include,
            _revinclude: revinclude,
            _summary: summary,
            _contained: contained,
            _containedType: containedType,
            code,
            datewritten,
            encounter,
            identifier,
            medication,
            patient,
            prescriber,
            status,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MedicationOrderBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * @todo Add general description for this endpoint
     *
     * @param {string} id TODO: type description here
     * @param {string} id1 (optional) Resource id (not a full URL)
     * @param {string} content (optional) Text search against the entire resource
     * @param {string} lastUpdated (optional) Date last updated. Server has discretion on the
     * boundary precision
     * @param {string} tag (optional) Search by a resource tag
     * @param {string} profile (optional) Search for all resources tagged with a profile
     * @param {string} security (optional) Search by a security label
     * @param {string} text (optional) Text search against the narrative
     * @param {string} list (optional) All resources in nominated list (by id, not a full URL)
     * @param {string} query (optional) Custom named query
     * @param {string} sort (optional) Order to sort results in (can repeat for inner sort orders)
     * @param {string} count (optional) Number of results per page
     * @param {string} include (optional) Other resources to include in the search results that
     * search matches point to
     * @param {string} revinclude (optional) Other resources to include in the search results when
     * they refer to search matches
     * @param {string} summary (optional) Just return the summary elements (for resources where
     * this is defined)
     * @param {string} contained (optional) Whether to return resources contained in other
     * resources in the search matches
     * @param {string} containedType (optional) If returning contained resources, whether to return
     * the contained or container resources
     * @param {string} actor (optional) Any one of the individuals participating in the
     * appointment
     * @param {string} date (optional) Appointment date/time
     * @param {object} identifier (optional) An Identifier of the Appointment
     * @param {string} location (optional) The Participation status of the subject, or other
     * participant on the appointment. Can be used to locate participants
     * that have not responded to meeting requests.
     * @param {string} patient (optional) One of the individuals of the appointment is this
     * patient
     * @param {string} practitioner (optional) One of the individuals of the appointment is this
     * practitioner
     * @param {string} status (optional) The overall status of the appointment
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientAppointmentById(
        id,
        id1,
        content,
        lastUpdated,
        tag,
        profile,
        security,
        text,
        list,
        query,
        sort,
        count,
        include,
        revinclude,
        summary,
        contained,
        containedType,
        actor,
        date,
        identifier,
        location,
        patient,
        practitioner,
        status,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}/Appointment'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _id1: id1,
            _content: content,
            _lastUpdated: lastUpdated,
            _tag: tag,
            _profile: profile,
            _security: security,
            _text: text,
            _list: list,
            _query: query,
            _sort: sort,
            _count: count,
            _include: include,
            _revinclude: revinclude,
            _summary: summary,
            _contained: contained,
            _containedType: containedType,
            actor,
            date,
            identifier,
            location,
            patient,
            practitioner,
            status,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'AppointmentBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * @todo Add general description for this endpoint
     *
     * @param {string} id TODO: type description here
     * @param {string} id1 (optional) Resource id (not a full URL)
     * @param {string} content (optional) Text search against the entire resource
     * @param {string} lastUpdated (optional) Date last updated. Server has discretion on the
     * boundary precision
     * @param {string} tag (optional) Search by a resource tag
     * @param {string} profile (optional) Search for all resources tagged with a profile
     * @param {string} security (optional) Search by a security label
     * @param {string} text (optional) Text search against the narrative
     * @param {string} list (optional) All resources in nominated list (by id, not a full URL)
     * @param {string} query (optional) Custom named query
     * @param {string} sort (optional) Order to sort results in (can repeat for inner sort orders)
     * @param {string} count (optional) Number of results per page
     * @param {string} include (optional) Other resources to include in the search results that
     * search matches point to
     * @param {string} revinclude (optional) Other resources to include in the search results when
     * they refer to search matches
     * @param {string} summary (optional) Just return the summary elements (for resources where
     * this is defined)
     * @param {string} contained (optional) Whether to return resources contained in other
     * resources in the search matches
     * @param {string} containedType (optional) If returning contained resources, whether to return
     * the contained or container resources
     * @param {string} category (optional) TODO: type description here
     * @param {string} criticality (optional) CRITL | CRITH | CRITU
     * @param {string} date (optional) When recorded
     * @param {object} identifier (optional) External ids for this item
     * @param {string} lastDate (optional) Date(/time) of last known occurrence of a reaction
     * @param {string} manifestation (optional) Clinical symptoms/signs associated with the Event
     * @param {string} onset (optional) Date(/time) when manifestations showed
     * @param {string} patient (optional) Who the sensitivity is for
     * @param {string} recorder (optional) Who recorded the sensitivity
     * @param {string} reporter (optional) Source of the information about the allergy
     * @param {string} route (optional) How the subject was exposed to the substance
     * @param {string} severity (optional) TODO: type description here
     * @param {string} status (optional) active | unconfirmed | confirmed | inactive | resolved |
     * refuted | entered-in-error
     * @param {string} substance (optional) Substance, (or class) considered to be responsible for
     * risk
     * @param {string} type (optional) allergy | intolerance - Underlying mechanism (if known)
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientAllergyIntoleranceById(
        id,
        id1,
        content,
        lastUpdated,
        tag,
        profile,
        security,
        text,
        list,
        query,
        sort,
        count,
        include,
        revinclude,
        summary,
        contained,
        containedType,
        category,
        criticality,
        date,
        identifier,
        lastDate,
        manifestation,
        onset,
        patient,
        recorder,
        reporter,
        route,
        severity,
        status,
        substance,
        type,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}/AllergyIntolerance'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _id1: id1,
            _content: content,
            _lastUpdated: lastUpdated,
            _tag: tag,
            _profile: profile,
            _security: security,
            _text: text,
            _list: list,
            _query: query,
            _sort: sort,
            _count: count,
            _include: include,
            _revinclude: revinclude,
            _summary: summary,
            _contained: contained,
            _containedType: containedType,
            category,
            criticality,
            date,
            identifier,
            lastDate,
            manifestation,
            onset,
            patient,
            recorder,
            reporter,
            route,
            severity,
            status,
            substance,
            type,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'AllergyIntoleranceBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * The read interaction accesses the current contents of a resource.
     *
     * @param {string} id TODO: type description here
     * @param {FormatEnum} format (optional) TODO: type description here
     * @param {SummaryEnum} summary (optional) TODO: type description here
     * @param {string} ifModifiedSince (optional) TODO: type description here
     * @param {string} ifNoneMatch (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientById(id, format, summary, ifModifiedSince, ifNoneMatch, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            _format: (format !== null) ? format : null,
            _summary: (summary !== null) ? summary : null,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'If-Modified-Since': ifModifiedSince,
            'If-None-Match': ifNoneMatch,
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'Patient');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * The delete interaction removes an existing resource.
     *
     * @param {string} id TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deletePatientById(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * The update interaction creates a new current version for an existing resource or creates
     * an initial version if no resource already exists for the given id.
     *
     * @param {string} id TODO: type description here
     * @param {Patient} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updatePatientById(id, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/{id}'}`;

        // process template parameters
        _queryBuilder = _apiHelper.appendUrlWithTemplateParameters(_queryBuilder, {
            id,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
        };

        // remove null values
        _apiHelper.cleanObject(body);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 422) {
                    const _err = { errorMessage: 'Unprocessable Entity - the proposed resource violated applicable FHIR profiles or server business rules',
                        errorCode: 422,
                        errorResponse: _response.body,
                    };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * This interaction searches a set of resources based on some filter criteria.
     *
     * @param {string} active (optional) Whether the patient record is active
     * @param {string} address (optional) An address in any kind of address/part of the patient
     * @param {string} addressCity (optional) A city specified in an address
     * @param {string} addressCountry (optional) A country specified in an address
     * @param {string} addressPostalcode (optional) A postalCode specified in an address
     * @param {string} addressState (optional) A state specified in an address
     * @param {string} addressUse (optional) A use code specified in an address
     * @param {string} animalBreed (optional) The breed for animal patients
     * @param {string} animalSpecies (optional) The species for animal patients
     * @param {string} birthdate (optional) The patient's date of birth
     * @param {string} careprovider (optional) Patient's nominated care provider, could be a care
     * manager, not the organization that manages the record
     * @param {string} deathdate (optional) The date of death has been provided and satisfies this
     * search value
     * @param {string} deceased (optional) This patient has been marked as deceased, or as a death
     * date entered
     * @param {string} email (optional) A value in an email contact
     * @param {string} family (optional) A portion of the family name of the patient
     * @param {string} gender (optional) Gender of the patient
     * @param {string} given (optional) A portion of the given name of the patient
     * @param {object} identifier (optional) A patient identifier
     * @param {string} language (optional) Language code (irrespective of use value)
     * @param {string} link (optional) All patients linked to the given patient
     * @param {string} name (optional) A portion of either family or given name of the patient
     * @param {string} organization (optional) The organization at which this person is a patient
     * @param {string} phone (optional) A value in a phone contact
     * @param {string} phonetic (optional) A portion of either family or given name using some kind
     * of phonetic matching algorithm
     * @param {string} telecom (optional) The value in any kind of telecom details of the patient
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatientSearch(
        active,
        address,
        addressCity,
        addressCountry,
        addressPostalcode,
        addressState,
        addressUse,
        animalBreed,
        animalSpecies,
        birthdate,
        careprovider,
        deathdate,
        deceased,
        email,
        family,
        gender,
        given,
        identifier,
        language,
        link,
        name,
        organization,
        phone,
        phonetic,
        telecom,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient/_search'}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            active,
            address,
            addressCity,
            addressCountry,
            addressPostalcode,
            addressState,
            addressUse,
            animalBreed,
            animalSpecies,
            birthdate,
            careprovider,
            deathdate,
            deceased,
            email,
            family,
            gender,
            given,
            identifier,
            language,
            link,
            name,
            organization,
            phone,
            phonetic,
            telecom,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'PatientBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * This interaction searches a set of resources based on some filter criteria.
     *

     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createPatientSearch(callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/Patient/_search'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'PatientBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * The create interaction creates a new resource in a server-assigned location.
     * If the client wishes to have control over the id of a newly submitted resource, it should
     * use the update interaction instead.
     *
     * @param {Patient} body TODO: type description here
     * @param {string} ifNoneExist (optional) name=value selective criteria
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createPatient(body, ifNoneExist, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/Patient'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'If-None-Exist': ifNoneExist,
        };

        // remove null values
        _apiHelper.cleanObject(body);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const _err = { errorMessage: 'Precondition Failed error indicating the client\'s criteria were not selective enough.',
                        errorCode: 412,
                        errorResponse: _response.body,
                    };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * This interaction searches a set of resources based on some filter criteria.
     *
     * @param {string} active (optional) Whether the patient record is active
     * @param {string} address (optional) An address in any kind of address/part of the patient
     * @param {string} addressCity (optional) A city specified in an address
     * @param {string} addressCountry (optional) A country specified in an address
     * @param {string} addressPostalcode (optional) A postalCode specified in an address
     * @param {string} addressState (optional) A state specified in an address
     * @param {string} addressUse (optional) A use code specified in an address
     * @param {string} animalBreed (optional) The breed for animal patients
     * @param {string} animalSpecies (optional) The species for animal patients
     * @param {string} birthdate (optional) The patient's date of birth
     * @param {string} careprovider (optional) Patient's nominated care provider, could be a care
     * manager, not the organization that manages the record
     * @param {string} deathdate (optional) The date of death has been provided and satisfies this
     * search value
     * @param {string} deceased (optional) This patient has been marked as deceased, or as a death
     * date entered
     * @param {string} email (optional) A value in an email contact
     * @param {string} family (optional) A portion of the family name of the patient
     * @param {string} gender (optional) Gender of the patient
     * @param {string} given (optional) A portion of the given name of the patient
     * @param {object} identifier (optional) A patient identifier
     * @param {string} language (optional) Language code (irrespective of use value)
     * @param {string} link (optional) All patients linked to the given patient
     * @param {string} name (optional) A portion of either family or given name of the patient
     * @param {string} organization (optional) The organization at which this person is a patient
     * @param {string} phone (optional) A value in a phone contact
     * @param {string} phonetic (optional) A portion of either family or given name using some kind
     * of phonetic matching algorithm
     * @param {string} telecom (optional) The value in any kind of telecom details of the patient
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getPatient(
        active,
        address,
        addressCity,
        addressCountry,
        addressPostalcode,
        addressState,
        addressUse,
        animalBreed,
        animalSpecies,
        birthdate,
        careprovider,
        deathdate,
        deceased,
        email,
        family,
        gender,
        given,
        identifier,
        language,
        link,
        name,
        organization,
        phone,
        phonetic,
        telecom,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient'}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            active,
            address,
            addressCity,
            addressCountry,
            addressPostalcode,
            addressState,
            addressUse,
            animalBreed,
            animalSpecies,
            birthdate,
            careprovider,
            deathdate,
            deceased,
            email,
            family,
            gender,
            given,
            identifier,
            language,
            link,
            name,
            organization,
            phone,
            phonetic,
            telecom,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'PatientBundle');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * The conditional delete interaction allows a client to delete an existing resource based on
     * some selection criteria, rather than by a specific logical id.
     *
     * @param {string} active (optional) Whether the patient record is active
     * @param {string} address (optional) An address in any kind of address/part of the patient
     * @param {string} addressCity (optional) A city specified in an address
     * @param {string} addressCountry (optional) A country specified in an address
     * @param {string} addressPostalcode (optional) A postalCode specified in an address
     * @param {string} addressState (optional) A state specified in an address
     * @param {string} addressUse (optional) A use code specified in an address
     * @param {string} animalBreed (optional) The breed for animal patients
     * @param {string} animalSpecies (optional) The species for animal patients
     * @param {string} birthdate (optional) The patient's date of birth
     * @param {string} careprovider (optional) Patient's nominated care provider, could be a care
     * manager, not the organization that manages the record
     * @param {string} deathdate (optional) The date of death has been provided and satisfies this
     * search value
     * @param {string} deceased (optional) This patient has been marked as deceased, or as a death
     * date entered
     * @param {string} email (optional) A value in an email contact
     * @param {string} family (optional) A portion of the family name of the patient
     * @param {string} gender (optional) Gender of the patient
     * @param {string} given (optional) A portion of the given name of the patient
     * @param {object} identifier (optional) A patient identifier
     * @param {string} language (optional) Language code (irrespective of use value)
     * @param {string} link (optional) All patients linked to the given patient
     * @param {string} name (optional) A portion of either family or given name of the patient
     * @param {string} organization (optional) The organization at which this person is a patient
     * @param {string} phone (optional) A value in a phone contact
     * @param {string} phonetic (optional) A portion of either family or given name using some kind
     * of phonetic matching algorithm
     * @param {string} telecom (optional) The value in any kind of telecom details of the patient
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deletePatient(
        active,
        address,
        addressCity,
        addressCountry,
        addressPostalcode,
        addressState,
        addressUse,
        animalBreed,
        animalSpecies,
        birthdate,
        careprovider,
        deathdate,
        deceased,
        email,
        family,
        gender,
        given,
        identifier,
        language,
        link,
        name,
        organization,
        phone,
        phonetic,
        telecom,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient'}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            active,
            address,
            addressCity,
            addressCountry,
            addressPostalcode,
            addressState,
            addressUse,
            animalBreed,
            animalSpecies,
            birthdate,
            careprovider,
            deathdate,
            deceased,
            email,
            family,
            gender,
            given,
            identifier,
            language,
            link,
            name,
            organization,
            phone,
            phonetic,
            telecom,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 404) {
                    const _err = { errorMessage: 'Not found', errorCode: 404, errorResponse: _response.body };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else if (_response.statusCode === 412) {
                    const _err = { errorMessage: 'Precondition Failed error indicating the client\'s criteria were not selective enough.',
                        errorCode: 412,
                        errorResponse: _response.body,
                    };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

    /**
     * The conditional update interaction allows a client to update an existing resource based on
     * some identification criteria, rather than by logical id.
     *
     * @param {string} active (optional) Whether the patient record is active
     * @param {string} address (optional) An address in any kind of address/part of the patient
     * @param {string} addressCity (optional) A city specified in an address
     * @param {string} addressCountry (optional) A country specified in an address
     * @param {string} addressPostalcode (optional) A postalCode specified in an address
     * @param {string} addressState (optional) A state specified in an address
     * @param {string} addressUse (optional) A use code specified in an address
     * @param {string} animalBreed (optional) The breed for animal patients
     * @param {string} animalSpecies (optional) The species for animal patients
     * @param {string} birthdate (optional) The patient's date of birth
     * @param {string} careprovider (optional) Patient's nominated care provider, could be a care
     * manager, not the organization that manages the record
     * @param {string} deathdate (optional) The date of death has been provided and satisfies this
     * search value
     * @param {string} deceased (optional) This patient has been marked as deceased, or as a death
     * date entered
     * @param {string} email (optional) A value in an email contact
     * @param {string} family (optional) A portion of the family name of the patient
     * @param {string} gender (optional) Gender of the patient
     * @param {string} given (optional) A portion of the given name of the patient
     * @param {object} identifier (optional) A patient identifier
     * @param {string} language (optional) Language code (irrespective of use value)
     * @param {string} link (optional) All patients linked to the given patient
     * @param {string} name (optional) A portion of either family or given name of the patient
     * @param {string} organization (optional) The organization at which this person is a patient
     * @param {string} phone (optional) A value in a phone contact
     * @param {string} phonetic (optional) A portion of either family or given name using some kind
     * of phonetic matching algorithm
     * @param {string} telecom (optional) The value in any kind of telecom details of the patient
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updatePatient(
        active,
        address,
        addressCity,
        addressCountry,
        addressPostalcode,
        addressState,
        addressUse,
        animalBreed,
        animalSpecies,
        birthdate,
        careprovider,
        deathdate,
        deceased,
        email,
        family,
        gender,
        given,
        identifier,
        language,
        link,
        name,
        organization,
        phone,
        phonetic,
        telecom,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _queryBuilder = `${_baseUri}${'/Patient'}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            active,
            address,
            addressCity,
            addressCountry,
            addressPostalcode,
            addressState,
            addressUse,
            animalBreed,
            animalSpecies,
            birthdate,
            careprovider,
            deathdate,
            deceased,
            email,
            family,
            gender,
            given,
            identifier,
            language,
            link,
            name,
            organization,
            phone,
            phonetic,
            telecom,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const _err = { errorMessage: 'Precondition Failed error indicating the client\'s criteria were not selective enough',
                        errorCode: 412,
                        errorResponse: _response.body,
                    };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }

}

module.exports = PatientController;
